<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1" name=viewport><meta content=nositelinkssearchbox name=google><meta content=notranslate name=google><title>JavaScript cooperative async processing - Friedemann Sommer</title><meta name=description><link href=https://www.friedemannsommer.com/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://www.friedemannsommer.com/sitemap.xml rel=sitemap title=Sitemap type=text/xml><link href="https://www.friedemannsommer.com/site.css?h=9bb41b85e54940f4fed368c65552aa0980ef77118ecc043190713245908cfbcd" rel=stylesheet><body><header><nav class="flexbox flexbox-horizontal" itemscope itemtype=https://schema.org/SiteNavigationElement><a href=https://www.friedemannsommer.com/ itemprop=url> <span itemprop=name>Home</span> </a><a href=https://www.friedemannsommer.com/blog/ itemprop=url> <span itemprop=name>Blog</span> </a><a href=https://www.friedemannsommer.com/contact/ itemprop=url> <span itemprop=name>Contact</span> </a></nav></header><div class=container><article class="flexbox flexbox-vertical" itemscope itemtype=https://schema.org/BlogPosting><header><h1 itemprop=headline>JavaScript cooperative async processing</h1><section class="meta muted flexbox flexbox-horizontal"><p><data value=published>Published: <time>2022-03-08</time> </data><p>4 minute read</section></header><hr><section itemprop=articleBody><p>As someone who is <em>somewhat</em> familiar with JavaScript I will try to explain how it's possible to execute <em>expensive</em> tasks on a "single-threaded" runtime. As you might have already guessed this has pros and cons, and it's <strong>no silver bullet</strong>. I refer to it as "cooperative processing", but it's also known as "<a rel="noopener nofollow noreferrer" title="Cooperative multitasking - Wikipedia" href=https://en.wikipedia.org/wiki/Cooperative_multitasking target=_blank>cooperative multitasking</a>". (This term is probably something most have heard from in context of operating systems.)<blockquote><p>I acknowledge that it's possible to implement this via <a rel="noopener nofollow noreferrer" title="Async Generator - MDN" href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator target=_blank>async* Generators</a>, but we won't be using them since they require <a rel="noopener nofollow noreferrer" title="Promise - MDN" href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise target=_blank>Promise</a> instances which <strong>can</strong> be relatively expensive.</blockquote><p>The following examples are designed to be used within browsers, but can also be used with <a rel="noopener nofollow noreferrer" href=https://nodejs.org/en/ target=_blank>Node.js</a>, <a rel="noopener nofollow noreferrer" href=https://deno.land/ target=_blank>Deno</a> or any other <a rel="noopener nofollow noreferrer" title="ECMAScript 5.1" href=https://262.ecma-international.org/5.1/ target=_blank>ES5</a> compatible runtime with <a rel="noopener nofollow noreferrer" title="HTML Timers" href=https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout-dev target=_blank>Timers</a>.<p>Given an example task to iterate through a large list of entries and apply some processing to them, some might implement this:<pre class=language-typescript data-lang=typescript style=background-color:#212121;color:#eeffff;><code class=language-typescript data-lang=typescript><span style=font-style:italic;color:#c792ea;>const </span><span>entries </span><span style=color:#89ddff;>= </span><span style=color:#ffcb6b;>Array</span><span>(</span><span style=color:#f78c6c;>10e8</span><span>)
</span><span style=font-style:italic;color:#c792ea;>let </span><span>result </span><span style=color:#89ddff;>= </span><span style=color:#f78c6c;>0
</span><span>
</span><span style=font-style:italic;color:#c792ea;>for </span><span>(</span><span style=font-style:italic;color:#c792ea;>const </span><span>entry </span><span style=color:#89ddff;>of </span><span>entries) </span><span style=color:#89ddff;>{
</span><span>    result </span><span style=color:#89ddff;>+= </span><span>entry
</span><span style=color:#89ddff;>}
</span></code></pre><p>Don't get me wrong, there is nothing wrong with this, if it's not blocking some other <em>higher</em> priority task. Which is nearly always the case if this or something similar is being run on the (browser) main thread. To work around this, I would prefer the following implementation:<pre class=language-typescript data-lang=typescript style=background-color:#212121;color:#eeffff;><code class=language-typescript data-lang=typescript><span style=font-style:italic;color:#c792ea;>const </span><span>entries </span><span style=color:#89ddff;>= </span><span style=color:#ffcb6b;>Array</span><span>(</span><span style=color:#f78c6c;>10e8</span><span>)
</span><span>
</span><span style=font-style:italic;color:#c792ea;>function </span><span style=color:#82aaff;>processEntries</span><span style=color:#89ddff;>(
</span><span>    </span><span style=color:#f78c6c;>entries</span><span style=color:#89ddff;>: </span><span style=color:#ffcb6b;>number</span><span>[]</span><span style=color:#89ddff;>,
</span><span>    </span><span style=color:#82aaff;>onComplete</span><span style=color:#89ddff;>: (</span><span style=color:#f78c6c;>sum</span><span style=color:#89ddff;>: </span><span style=color:#ffcb6b;>number</span><span style=color:#89ddff;>) </span><span style=font-style:italic;color:#c792ea;>=> </span><span style=color:#ffcb6b;>void
</span><span style=color:#89ddff;>): </span><span style=color:#ffcb6b;>void </span><span style=color:#89ddff;>{
</span><span>    </span><span style=font-style:italic;color:#c792ea;>const </span><span>length </span><span style=color:#89ddff;>= </span><span>entries</span><span style=color:#89ddff;>.</span><span>length
</span><span>    </span><span style=font-style:italic;color:#c792ea;>let </span><span>offset </span><span style=color:#89ddff;>= </span><span style=color:#f78c6c;>0
</span><span>    </span><span style=font-style:italic;color:#c792ea;>let </span><span>result </span><span style=color:#89ddff;>= </span><span style=color:#f78c6c;>0
</span><span>
</span><span>    </span><span style=font-style:italic;color:#c792ea;>function </span><span style=color:#82aaff;>_process</span><span style=color:#89ddff;>(): </span><span style=color:#ffcb6b;>void </span><span style=color:#89ddff;>{
</span><span style=color:#89ddff;>        </span><span style=font-style:italic;color:#4a4a4a;>// process up to fifty entries at once
</span><span>        </span><span style=font-style:italic;color:#c792ea;>const </span><span>limit </span><span style=color:#89ddff;>= </span><span style=color:#f78c6c;>Math</span><span style=color:#89ddff;>.</span><span style=color:#82aaff;>min</span><span>(offset </span><span style=color:#89ddff;>+ </span><span style=color:#f78c6c;>50</span><span style=color:#89ddff;>, </span><span>length)
</span><span>
</span><span>        </span><span style=font-style:italic;color:#c792ea;>for </span><span>(</span><span style=font-style:italic;color:#c792ea;>let </span><span>index </span><span style=color:#89ddff;>= </span><span>offset</span><span style=color:#89ddff;>; </span><span>index </span><span style=color:#89ddff;>< </span><span>limit</span><span style=color:#89ddff;>; </span><span>index</span><span style=color:#89ddff;>++</span><span>) </span><span style=color:#89ddff;>{
</span><span>            result </span><span style=color:#89ddff;>+= </span><span>entries[index]
</span><span>        </span><span style=color:#89ddff;>}
</span><span>
</span><span>        </span><span style=font-style:italic;color:#c792ea;>if </span><span>(limit </span><span style=color:#89ddff;>=== </span><span>length)</span><span style=color:#89ddff;>{
</span><span style=color:#89ddff;>            </span><span style=font-style:italic;color:#4a4a4a;>// we've reached the end
</span><span>            </span><span style=color:#82aaff;>onComplete</span><span>(result)
</span><span>        </span><span style=color:#89ddff;>} </span><span style=font-style:italic;color:#c792ea;>else </span><span style=color:#89ddff;>{
</span><span style=color:#89ddff;>            </span><span style=font-style:italic;color:#4a4a4a;>// advance offset by batch size
</span><span>            offset </span><span style=color:#89ddff;>+= </span><span style=color:#f78c6c;>50
</span><span style=color:#89ddff;>            </span><span style=font-style:italic;color:#4a4a4a;>// 24ms since we're targeting 60 FPS
</span><span style=color:#89ddff;>            </span><span style=font-style:italic;color:#4a4a4a;>// 16ms * 1.5 = 24ms
</span><span>            </span><span style=color:#82aaff;>setTimeout</span><span>(_process</span><span style=color:#89ddff;>, </span><span style=color:#f78c6c;>24</span><span>)
</span><span>        </span><span style=color:#89ddff;>}
</span><span>    </span><span style=color:#89ddff;>}
</span><span>
</span><span>    </span><span style=color:#82aaff;>_process</span><span>()
</span><span style=color:#89ddff;>}
</span></code></pre><p>The second example will be slower overall, but since execution is "paused" after fifty entries the main thread can process user input or execute other tasks. Some might be thinking: "Why would I write more code and have it execute slower?" That's a good question!<p>Let me <em>try</em> to explain it by using a relatively modest monitoring dashboard as an example. Given that example let's say there are fourteen different widgets that need to be updated every five seconds with data from the last thirty minutes. A given data point represents one second, which means there are <code>14 widgets * (30 minutes * 60 seconds)</code> entries which need to be processed. This will yield up to <code>25200</code> entries, which is a relatively modest number for a modern PC, but updating all fourteen widgets in one task will lead to unresponsiveness for a small amount of time which isn't a great user experience.<p>A possible solution would be, to process the data per widget per time budget (which was <code>24ms</code> in the previous example). You are correct in thinking that this might lead to visual differences, but these should only be minor and be resolved within the next one to three seconds (depending on the users PC). Overall this <em>should</em> be a more responsive user experience than updating them all at once. <strong>But</strong> since every application is at least slightly different and might have different goals this isn't necessary.<p>The given example does not reflect most <em>real</em> tasks, but I hope that it was understandable. In most <em>real</em> applications these processing times simply add up by abstraction or other tasks running "simultaneously". Some applications can use <a rel="noopener nofollow noreferrer" title="Web Workers - MDN" href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers target=_blank>Web Workers</a> or <a rel="noopener nofollow noreferrer" title="WebAssembly - MDN" href=https://developer.mozilla.org/en-US/docs/WebAssembly target=_blank>WebAssembly</a> to process tasks outside the main thread, but this creates other hurdles which may not be worth for some.<p>All right, that's all. If I made a mistake or something isn't clear, try contacting me <a rel="noopener nofollow noreferrer" title="free_some_mem on Twitter" href=https://twitter.com/free_some_mem target=_blank>@free_some_mem</a>.</section></article></div>